% SURF_INTERP Construct a surface plot with interpoalted data.
%
% h = SURF_INTERP(meshes, idgrids, nodedata, data)
% h = SURF_INTERP(ax, meshes, idgrids, nodedata, data)
% h = SURF_INTERP(ax, meshes, idgrids, nodedata, data,...
%       'XRange',              [xmin xmax],   ...
%       'YRange',              [ymin ymax],   ...
%       'XResolution',         xres,          ...
%       'YResolution',         yres,          ...
%       'EdgeColor',           edge_color,    ...
%       'FaceColor',           face_color,    ...
%       'XOffset',             x_offset,      ...
%       'YOffset',             y_offset,      ...
%       'DistanceMultiplier',  dist_mult,     ...
%       )
%
%
% meshes, idgrids, and nodedata must be the corresponding variables generated by
% multimesh_2d.
% data should be a vector of real values, arranged to correspond to the nodes of
% the multimesh.
%
% SURF_INTERP interpolates the data in the multimesh and displays a surface plot
% of the result. The output, h, is a handle to the surface object.
%
% Several optional arguments are allowed.
% Plot settings:
%  'XRange':             Min and max x values setting the plot limits
%  'YRange':             Min and max y values setting the plot limits
%  'XResolution':        Number of points in x for the interpolated grid.
%                        Default: 50
%  'YResolution':        Number of points in y for the interpolated grid.
%                        Default: 50
%  'EdgeColor':          Color of edges (just as in SURF)
%  'FaceColor':          Color of faces (just as in SURF)
%
%  A few additional options are provided for modifying the x and y axes, since
%  it is inconvenient to do so from within nodedata.
%  'XOffset':            Constant to add to x
%  'YOffset':            Constant to add to y
%  'DistanceMultiplier': Constant by which to multiply x and y
%

% Author: Nicholas White <nwhite@caltech.edu>
%         Laboratory of Interfacial and Small Scale Transport (LIS2T)
%         Dept. of Applied Physics, Caltech
%         https://www.troian.caltech.edu
% Created: 2019-05-21
% Updated: 2019-05-21

% Copyright 2020 Nicholas C. White
%
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
%
%    http://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.


function h = surf_interp(varargin)

% TODO: validate input and allow optional arguments
% e.g., levelsN, ax, ...
hasax = isa(varargin{1},'matlab.graphics.axis.Axes');



parser = inputParser;
if (hasax)
    parser.addRequired('axes');
end
parser.addRequired('meshes', @(x) iscell(x));
parser.addRequired('idgrids', @(x) iscell(x));
parser.addRequired('nodedata', @(x) isstruct(x));
parser.addRequired('data', @(x) (isvector(x) && min(size(x))==1));
parser.addParameter('XRange', [], @(x) (isvector(x) && isnumeric(x) && length(x)==2 && min(size(x))==1));
parser.addParameter('YRange', [], @(x) (isvector(x) && isnumeric(x) && length(x)==2 && min(size(x))==1));
parser.addParameter('XResolution', 50, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('YResolution', 50, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('EdgeColor', 'none', @(x) ischar(x));
parser.addParameter('FaceColor', [], @(x) ischar(x));
parser.addParameter('DistanceMultiplier', 1, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('XOffset', 0, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('YOffset', 0, @(x) isscalar(x) && isnumeric(x));
parse(parser, varargin{:});
meshes = parser.Results.meshes;
idgrids = parser.Results.idgrids;
nodedata = parser.Results.nodedata;
data = parser.Results.data;
xrange = parser.Results.XRange;
yrange = parser.Results.YRange;
xres = parser.Results.XResolution;
yres = parser.Results.YResolution;
edge_color = parser.Results.EdgeColor;
face_color= parser.Results.FaceColor;
dist_conv = parser.Results.DistanceMultiplier;
xoffset = parser.Results.XOffset;
yoffset = parser.Results.YOffset;

assert( (xres >= 2) && (yres >= 2) && (xres <= 1000) && (yres <= 1000) , 'XResolution and YResolution must be between 2 and 1000');
xres = ceil(xres);
yres = ceil(yres);

if (hasax)
    ax = parser.Results.axes;
else
    ax = gca;
end

holding = ishold(ax);

meshN = length(meshes);
assert(length(idgrids) == meshN);

xmin = Inf;
xmax = -Inf;
ymin = Inf;
ymax = -Inf;
for j = 1:meshN
    xs = meshes{j}{1};
    ys = meshes{j}{2};
    xmin = min(xmin, min(xs));
    xmax = max(xmax, max(xs));
    ymin = min(ymin, min(ys));
    ymax = max(ymax, max(ys));
end
if length(xrange) == 0
    xrange = [xmin xmax];
end
if length(yrange) == 0
    yrange = [ymin ymax];
end
assert( (xrange(2) > xrange(1)) && (yrange(2) > yrange(1)) , 'XRange and YRange must be nonzero.');

% Interpolate data
xs_interp = ([0:xres-1]/(xres-1)) * (xrange(2) - xrange(1)) + xrange(1);
ys_interp = ([0:yres-1]/(yres-1)) * (yrange(2) - yrange(1)) + yrange(1);
[xg_interp, yg_interp] = ndgrid(xs_interp, ys_interp);
data_interp = griddata(nodedata.x, nodedata.y, data, xg_interp, yg_interp, 'cubic');

% Plot interpolated data
if isempty(face_color)
    h  = surf(ax, (xg_interp+xoffset)*dist_conv, (yg_interp+yoffset)*dist_conv, data_interp, 'EdgeColor', edge_color);
else
    h  = surf(ax, (xg_interp+xoffset)*dist_conv, (yg_interp+yoffset)*dist_conv, data_interp, 'EdgeColor', edge_color, 'FaceColor', face_color);
end
xlim(ax, (xrange+xoffset)*dist_conv);
ylim(ax, (yrange+yoffset)*dist_conv);


end
