% CONTOURF_MULTI Construct a layered contour plot with multiple grids.
%
% output = CONTOURF_MULTI(meshes, idgrids, nodedata, data)
% output = CONTOURF_MULTI(ax, meshes, idgrids, nodedata, data)
% output = CONTOURF_MULTI(ax, meshes, idgrids, nodedata, data,...
%       'XRange',              [xmin xmax],   ...
%       'YRange',              [ymin ymax],   ...
%       'Levels',              num_levels,    ...
%       'LevelList',           [level list],  ...
%       'LineColor',           line_color,    ...
%       'Fill',                true/false,    ...
%       'AxesEqual',           true/false,    ...
%       'XOffset',             x_offset,      ...
%       'YOffset',             y_offset,      ...
%       'DistanceMultiplier',  dist_mult,     ...
%       )
%
%
% meshes, idgrids, and nodedata must be the corresponding variables generated by
% multimesh_2d.
% data should be a vector of real values, arranged to correspond to the nodes of
% the multimesh.
%
% CONTOURF_MULTI constructs contour plots of each grid in the multimesh and
% stacks them up. The output is a cell list of the form {{c1,h1}, {c2,h2},...},
% where c is the contour data and h is the handle to the corresponding contour
% object.
%
% Several optional arguments are allowed.
% Plot settings:
%  'XRange':             Min and max x values setting the plot limits
%  'YRange':             Min and max y values setting the plot limits
%  'Levels':             Number of contour levels to draw
%  'LevelList':          Specific list of values at which to draw contours
%  'LineColor':          Color of contour lines
%  'Fill':               true => plot with CONTOURF. false => plot with CONTOUR
%  'AxesEqual':          true => x and y will have the same scale
%
%  A few additional options are provided for modifying the x and y axes, since
%  it is inconvenient to do so from within nodedata.
%  'XOffset':            Constant to add to x
%  'YOffset':            Constant to add to y
%  'DistanceMultiplier': Constant by which to multiply x and y
%

% Author: Nicholas White <nwhite@caltech.edu>
%         Laboratory of Interfacial and Small Scale Transport (LIS2T)
%         Dept. of Applied Physics, Caltech
%         https://www.troian.caltech.edu
% Created: 2019-04-02
% Updated: 2019-05-21

% Copyright 2020 Nicholas C. White
%
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
%
%    http://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.


function output = contourf_multi(varargin)

hasax = isa(varargin{1},'matlab.graphics.axis.Axes');



parser = inputParser;
if (hasax)
    parser.addRequired('axes');
end
parser.addRequired('meshes', @(x) iscell(x));
parser.addRequired('idgrids', @(x) iscell(x));
parser.addRequired('nodedata', @(x) isstruct(x));
parser.addRequired('data', @(x) (isvector(x) && min(size(x))==1));
parser.addParameter('XRange', [], @(x) (isvector(x) && isnumeric(x) && length(x)==2 && min(size(x))==1));
parser.addParameter('YRange', [], @(x) (isvector(x) && isnumeric(x) && length(x)==2 && min(size(x))==1));
parser.addParameter('LevelList', [], @(x) (isvector(x) && isnumeric(x) && min(size(x))==1 && length(x) > 1));
parser.addParameter('Levels', 6, @(x) (isscalar(x) && isnumeric(x)));
parser.addParameter('LineColor', 'k', @(x) ischar(x));
parser.addParameter('Fill', true, @(x) isscalar(x));
parser.addParameter('DistanceMultiplier', 1, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('XOffset', 0, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('YOffset', 0, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('AxesEqual', false, @(x) isscalar(x));
parse(parser, varargin{:});
meshes = parser.Results.meshes;
idgrids = parser.Results.idgrids;
nodedata = parser.Results.nodedata;
data = parser.Results.data;
xrange = parser.Results.XRange;
yrange = parser.Results.YRange;
levellist = parser.Results.LevelList;
levelsN = parser.Results.Levels;
linecolor = parser.Results.LineColor;
should_fill = parser.Results.Fill;
dist_conv = parser.Results.DistanceMultiplier;
x_offset = parser.Results.XOffset;
y_offset = parser.Results.YOffset;
equal_axes = parser.Results.AxesEqual;

if (hasax)
    ax = parser.Results.axes;
else
    ax = gca;
end

holding = ishold(ax);

meshN = length(meshes);
assert(length(idgrids) == meshN);

xmin = Inf;
xmax = -Inf;
ymin = Inf;
ymax = -Inf;
for j = 1:meshN
    xs = meshes{j}{1};
    ys = meshes{j}{2};
    xmin = min(xmin, min(xs));
    xmax = max(xmax, max(xs));
    ymin = min(ymin, min(ys));
    ymax = max(ymax, max(ys));
end
if length(xrange) == 0
    xrange = [xmin xmax];
end
if length(yrange) == 0
    yrange = [ymin ymax];
end


% Setup contour levels
if length(levellist) == 0
    checkdata = data( (~isnan(data)) & (nodedata.x' >= xrange(1)) & (nodedata.x' <= xrange(2)) & (nodedata.y' >= yrange(1)) & (nodedata.y' <= yrange(2)));
    cmin = min(checkdata);
    cmax = max(checkdata);

    if ~isempty(cmin) && ~isempty(cmax)
        levellist = [0:1/(levelsN+1):1]*(cmax - cmin) + cmin;
    else
        levellist = [];
    end
else
    cmin = min(levellist);
    cmax = max(levellist);
end


output = {};

for j = 1:meshN
    xs = meshes{j}{1};
    ys = meshes{j}{2};
    [xg, yg] = ndgrid(xs, ys);
    idgrid = idgrids{j};

    if should_fill
        [c, h]  = contourf(ax, (xg+x_offset)*dist_conv, (yg+y_offset)*dist_conv, data(idgrid), 'LevelList', levellist, 'LineColor', linecolor);
        if ~isempty(cmin) && ~isempty(cmax)
            caxis(ax, [cmin cmax]);
        end
    else
        [c, h]  = contour(ax, (xg+x_offset)*dist_conv, (yg+y_offset)*dist_conv, data(idgrid), 'LevelList', levellist, 'LineColor', linecolor);
    end
    if (j == 1)
        if (equal_axes)
            axis(ax,'equal');
        end
    end
    output{end+1} = {c,h};
    hold(ax, 'on');
end
xlim(ax, (xrange+x_offset)*dist_conv);
ylim(ax, (yrange+y_offset)*dist_conv);

hold(ax, 'off');



if holding
    hold(ax, 'on');
end


end
