% CONTOURF_SLICE_3D Construct contour plot slices with interpolated data.
%
% h = CONTOURF_SLICE_3D(meshes, idgrids, nodedata, data,...
%   xslice, yslice, zslice)
% h = CONTOURF_SLICE_3D(ax, meshes, idgrids, nodedata, data,...
%   xslice, yslice, zslice)
% h = CONTOURF_SLICE_3D(ax, meshes, idgrids, nodedata, data,...
%   xslice, yslice, zslice,...
%  'XRange',              [xmin xmax],   ...
%  'YRange',              [ymin ymax],   ...
%  'ZRange',              [zmin zmax],   ...
%  'XResolution',         xres,          ...
%  'YResolution',         yres,          ...
%  'ZResolution',         zres,          ...
%  'Levels',              num_levels,    ...
%  'LevelList',           [level list],  ...
%  'LineColor',           line_color,    ...
%  'Fill',                true/false,    ...
%  'AxesEqual',           true/false,    ...
%  'XOffset',             x_offset,      ...
%  'YOffset',             y_offset,      ...
%  'ZOffset',             z_offset,      ...
%  'DistanceMultiplier',  dist_mult,     ...
%  )
%
%
% meshes, idgrids, and nodedata must be the corresponding variables generated by
% multimesh_3d.
% data should be a vector of real values, arranged to correspond to the nodes of
% the multimesh.
% xslice, yslice, and zslice define slice planes (see SLICE documentation).
%
% CONTOURF_SLICE_3D interpolates the data in the multimesh and displays a
% contour plot of the result. The output is the same as that of the standard
% CONTOURSLICE, c being the contour data and h a handle to the contour object.
%
% Several optional arguments are allowed.
% Plot settings:
%  'XRange':             Min and max x values setting the plot limits
%  'YRange':             Min and max y values setting the plot limits
%  'ZRange':             Min and max z values setting the plot limits
%  'XResolution':        Number of points in x for the interpolated grid.
%                        Default: 50
%  'YResolution':        Number of points in y for the interpolated grid.
%                        Default: 50
%  'ZResolution':        Number of points in z for the interpolated grid.
%                        Default: 50
%  'Levels':             Number of contour levels to draw
%  'LevelList':          Specific list of values at which to draw contours
%  'LineColor':          Color of contour lines
%  'Fill':               true => plot with CONTOURF. false => plot with CONTOUR
%  'AxesEqual':          true => x and y will have the same scale
%
%  A few additional options are provided for modifying the x and y axes, since
%  it is inconvenient to do so from within nodedata.
%  'XOffset':            Constant to add to x
%  'YOffset':            Constant to add to y
%  'ZOffset':            Constant to add to z
%  'DistanceMultiplier': Constant by which to multiply x, y, and z
%

% Author: Nicholas White <nwhite@caltech.edu>
%         Laboratory of Interfacial and Small Scale Transport (LIS2T)
%         Dept. of Applied Physics, Caltech
%         https://www.troian.caltech.edu
% Created: 2019-07-02
% Updated: 2019-07-02

% Copyright 2020 Nicholas C. White
%
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
%
%    http://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.


function h = contourf_slice_3d(varargin)

hasax = isa(varargin{1},'matlab.graphics.axis.Axes');



parser = inputParser;
if (hasax)
    parser.addRequired('axes');
end
parser.addRequired('meshes', @(x) iscell(x));
parser.addRequired('idgrids', @(x) iscell(x));
parser.addRequired('nodedata', @(x) isstruct(x));
parser.addRequired('data', @(x) isvector(x));
parser.addRequired('xslice', @(x) (isvector(x) || isempty(x)));
parser.addRequired('yslice', @(x) (isvector(x) || isempty(x)));
parser.addRequired('zslice', @(x) (isvector(x) || isempty(x)));
parser.addParameter('XRange', [], @(x) (isvector(x) && isnumeric(x) && length(x)==2));
parser.addParameter('YRange', [], @(x) (isvector(x) && isnumeric(x) && length(x)==2));
parser.addParameter('ZRange', [], @(x) (isvector(x) && isnumeric(x) && length(x)==2));
parser.addParameter('XResolution', 50, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('YResolution', 50, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('ZResolution', 50, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('LevelList', [], @(x) (isvector(x) && isnumeric(x) && length(x) > 1));
parser.addParameter('Levels', 6, @(x) (isscalar(x) && isnumeric(x)));
parser.addParameter('LineColor', 'k', @(x) ischar(x));
parser.addParameter('Fill', true, @(x) isscalar(x));
parser.addParameter('DistanceMultiplier', 1, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('XOffset', 0, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('YOffset', 0, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('ZOffset', 0, @(x) isscalar(x) && isnumeric(x));
parser.addParameter('AxesEqual', false, @(x) isscalar(x));
parse(parser, varargin{:});
meshes = parser.Results.meshes;
idgrids = parser.Results.idgrids;
nodedata = parser.Results.nodedata;
data = parser.Results.data;
xslice = parser.Results.xslice;
yslice = parser.Results.yslice;
zslice = parser.Results.zslice;
xrange = parser.Results.XRange;
yrange = parser.Results.YRange;
zrange = parser.Results.ZRange;
xres = parser.Results.XResolution;
yres = parser.Results.YResolution;
zres = parser.Results.ZResolution;
levellist = parser.Results.LevelList;
levelsN = parser.Results.Levels;
linecolor = parser.Results.LineColor;
should_fill = parser.Results.Fill;
dist_conv = parser.Results.DistanceMultiplier;
xoffset = parser.Results.XOffset;
yoffset = parser.Results.YOffset;
zoffset = parser.Results.ZOffset;
equal_axes = parser.Results.AxesEqual;

assert( (xres >= 2) && (yres >= 2) && (zres >= 2) && ...
        (xres <= 1000) && (yres <= 1000) && (zres <= 1000),...
        'XResolution, YResolution, and ZResolution must be between 2 and 1000');
xres = ceil(xres);
yres = ceil(yres);
zres = ceil(zres);

if (hasax)
    ax = parser.Results.axes;
else
    ax = gca;
end

holding = ishold(ax);

meshN = length(meshes);
assert(length(idgrids) == meshN);

xmin = Inf;
xmax = -Inf;
ymin = Inf;
ymax = -Inf;
zmin = Inf;
zmax = -Inf;
for j = 1:meshN
    xs = meshes{j}{1};
    ys = meshes{j}{2};
    zs = meshes{j}{3};
    xmin = min(xmin, min(xs));
    xmax = max(xmax, max(xs));
    ymin = min(ymin, min(ys));
    ymax = max(ymax, max(ys));
    zmin = min(zmin, min(zs));
    zmax = max(zmax, max(zs));
end
if length(xrange) == 0
    xrange = [xmin xmax];
end
if length(yrange) == 0
    yrange = [ymin ymax];
end
if length(zrange) == 0
    zrange = [zmin zmax];
end
assert( (xrange(2) > xrange(1)) && (yrange(2) > yrange(1)) && (zrange(2) > zrange(1)),...
        'XRange, YRange, and ZRange must be nonzero.');


% Setup contour levels
% TODO: should this be done _after_ interpolation?
if length(levellist) == 0
    checkdata = data( (~isnan(data)) & (nodedata.x' >= xrange(1)) & (nodedata.x' <= xrange(2)) & (nodedata.y' >= yrange(1)) & (nodedata.y' <= yrange(2)) & (nodedata.z' >= zrange(1)) & (nodedata.z' <= zrange(2)) );
    cmin = min(checkdata);
    cmax = max(checkdata);
    levellist = [0:1/(levelsN+1):1]*(cmax - cmin) + cmin;
else
    cmin = min(levellist);
    cmax = max(levellist);
end

% Interpolate data
xs_interp = ([0:xres-1]/(xres-1)) * (xrange(2) - xrange(1)) + xrange(1);
ys_interp = ([0:yres-1]/(yres-1)) * (yrange(2) - yrange(1)) + yrange(1);
zs_interp = ([0:zres-1]/(zres-1)) * (zrange(2) - zrange(1)) + zrange(1);
[xg_interp, yg_interp, zg_interp] = meshgrid(xs_interp, ys_interp, zs_interp);
data_interp = griddata(nodedata.x, nodedata.y, nodedata.z, data, xg_interp, yg_interp, zg_interp, 'natural');

% Contour interpolated data
if should_fill
    %[c, h]  = contourf(ax, (xg_interp+xoffset)*dist_conv, (yg_interp+yoffset)*dist_conv, data_interp, 'LevelList', levellist, 'LineColor', linecolor);
    %caxis(ax, [cmin cmax]);
    h  = contourslice(ax, (xg_interp+xoffset)*dist_conv, (yg_interp+yoffset)*dist_conv, (zg_interp+zoffset)*dist_conv, data_interp, (xslice + xoffset)*dist_conv, (yslice + yoffset)*dist_conv, (zslice + zoffset)*dist_conv, levellist);
    set(h, 'EdgeColor', [0 0 0])
    hold(ax, 'on')
    hslice  = slice(ax, (xg_interp+xoffset)*dist_conv, (yg_interp+yoffset)*dist_conv, (zg_interp+zoffset)*dist_conv, data_interp, (xslice + xoffset)*dist_conv, (yslice + yoffset)*dist_conv, (zslice + zoffset)*dist_conv);
    set(hslice, 'EdgeColor', 'none');
else
    %[c, h]  = contour(ax, (xg_interp+xoffset)*dist_conv, (yg_interp+yoffset)*dist_conv, data_interp, 'LevelList', levellist, 'LineColor', linecolor);
end
if (equal_axes)
    axis(ax,'equal');
end
xlim(ax, (xrange+xoffset)*dist_conv);
ylim(ax, (yrange+yoffset)*dist_conv);
zlim(ax, (zrange+zoffset)*dist_conv);

if (holding)
    hold(ax, 'on')
else
    hold(ax, 'off')
end

end

